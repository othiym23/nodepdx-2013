<!doctype html>
<html lang="en">

<head>
<meta charset="utf-8">

<title>Do as I say, not as I do.</title>

<meta name="description" content="How to write Node code that won't break in a month.">
<meta name="author" content="Forrest Lehwalder Norvell">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<link rel="stylesheet" href="css/reveal.min.css">
<link rel="stylesheet" href="css/theme/solarized.css" id="theme">

<!-- For syntax highlighting -->
<link rel="stylesheet" href="lib/css/solarized-light.css">

<!-- If the query includes 'print-pdf', use the PDF print sheet -->
<script>
document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
</script>

<!--[if lt IE 9]>
                <script src="lib/js/html5shiv.js"></script>
                <![endif]-->
</head>

<body>

<div class="reveal">

  <!-- Any section element inside of this container is displayed as a slide -->
  <div class="slides">

    <section>
      <h1>Do as I say, not as I do</h1>
      <h3>Lessons learned from a year of trial by fire</h3>
      <p><small><a href="http://twitter.com/othiym23">Forrest L Norvell</a>, <a href="http://newrelic.com">New Relic</a></small></p>
      <p><a href="http://is.gd/nodepdx2013">http://is.gd/nodepdx2013</a></p>
    </section>

    <section>
      <h2>Who / What / Why</h2>

      <ul>
        <li>2 years writing Node.js for a living.</li>
        <li>1 year writing Node.js for New Relic.</li>
      </ul>

      <p class="fragment"><br/>New Relic's job is not to tell you how to write your code.
      Our job is to give you the tools you need to figure out how to improve
      your code yourself.</p>

      <p>&nbsp;</p>

      <p class="fragment">This talk is a mixture of practical advice and naked self-interest:
      if everyone followed these guidelines, my job would be much easier.</p>
    </section>

    <section>
      <h2>Writing A New Relic Agent Is Easy</h2>

      <ul>
        <li class="fragment">must not crash</li>
        <li class="fragment">must be easy to use</li>
        <li class="fragment">must be dead simple to deploy</li>
        <li class="fragment">must be fast</li>
        <li class="fragment">must be small</li>
        <li class="fragment">must work like other New Relic Agents</li>
        <li class="fragment">must run synchronously</li>
        <li class="fragment">must be deterministic</li>
        <li class="fragment">should support troubleshooting</li>
        <li class="fragment">shouldn't confuse concerns</li>
        <li class="fragment">should alter semantics as little as possible</li>
        <li class="fragment">should alter operational environment as little as possible</li>
        <li class="fragment">should depend on as little outside core as possible</li>
        <li class="fragment">should care very little about how user code is organized or written</li>
      </ul>

      <aside class="notes">
        * no crashing: JS's dynamism makes this a difficult promise to make.
          The best you can do is be very rigorous about testing.
        * ease of use: absolutely critical to get people using the tool, lack
          of strong community conventions makes this a huge source of debate
        * simple to deploy: the Node way is to use lots of small, loosely-coupled
          modules, but that increases the fragility of the deployment process
        * fast:
          * the New Relic handshake happens within the Node process, with its
            own asynchronous flow
          * error tracing and monkeypatching can inhibit optimization, incurring
            overhead
        * small: agent gathers lots of information and does in-memory aggregation,
          so the added memory over time is relatively minor, but results in lots
          of ephemeral objects being created, which can cause pressure on the GC
        * like other agents: asynchronous execution doesn't look much like the
          profile stacktraces generated by other languages, and many of Node's
          use cases don't really fit within New Relic's transactional model
        * synchronous:
          * timing information needs to be gathered as closely to the
            work site as possible, which is another thing that leads to
            closure creation, which further increases GC pressure
          * zlib can't be used synchronously, so encoding data is unavoidably
            asynchronous
          * logging can be synchronous or fast, but not both
        * deterministic:
          * GC pressure means that GC behavior changes -- more frequent GC
            passes, memory usage may increase
          * monkeypatches core functions, which can change their performance
            under load
        * troubleshooting:
          * logging is I/O heavy and time-consuming
          * dtrace and node-dtrace can provide lots of insight, but native
            components complicate deployment and DTrace support is limited
            to a relatively small subset of users
        * separate concerns: execution tracing and error capturing conflict
          due to Node's minimal version of asynchronous programming
        * preserve semantics: internals change across versions, particularly
          around error-handling -- moving target
        * operational environment:
          * the entire purpose of the agent is to monkeypatch the core of the
            runtime environment â€“ I/O, async behavior, error handling
          * sometimes the core has bugs that need to be avoided or worked around
            that only show up in very specific circumstances, necessitating
            special-purpose code
        * few dependencies: I'm not going to write my own logging module
        * users do their own thing: some control flow tools will work better
          with the agent than others
      </aside>
    </section>

    <section>
      <h2>...wh- what?</h2>
    </section>

    <section>
      <section>
        <h1>THE PROBLEM:</h1>
        <h3>JavaScript is not a pure language.</h3>

        <ul>
          <li>It is <i>possible</i> to use fundamental functional programming
          techniques in JavaScript.</li>
          <li>It is <i>possible</i> to use inheritance and simulate classes in
          JavaScript.</li>
          <li>This doesn't mean either is a good idea.</li>
        </ul>

        <aside class="notes">
          1. monads and lenses
          2. CoffeeScript provides a simulation of classes as transpiled sugar.
        </aside>
      </section>

      <section>
        <h2>OO vs FP, Mutation vs Closures: FIGHT!</h2>

        <ul>
          <li>Closures can prevent JIT optimization.</li>
          <li>Functional techniques that depend on purity are hard to make work transparently
          with mutation-heavy code.</li>
        </ul>
      </section>

      <section>
        <h1>THE PROBLEM, cont'd:</h1>
        <ul>
          <li>JavaScript, being dynamic, has no type system.</li>
          <li>Cleverness impairs collaboration.</li>
          <li>In JavaScript, clarity and effectiveness are always in tension.</li>
        </ul>

        <aside class="notes">
          1. if you're using abstractions like monads, you're responsible for
             keeping the rules for how they're used in your head.
          2. One of the primary jobs of a static type system is to help the
             compiler keep you out of trouble.
          3. JavaScript tooling for dealing with the combination of anonymous
             functions and mutation is not what it could be.
        </aside>
      </section>

      <section>
        <h1>THE PROBLEM: COMPLEXITY IS YOUR ENEMY</h1>
      </section>

      <aside class="notes">
        JavaScript's mongrel pedigree fosters complexity and cleverness to deal with
        the hard tradeoffs it imposes. Keep it simple.
      </aside>
    </section>

    <section>
      <section>
        <h2>Writing tooling is a special challenge</h2>

        <ul>
          <li>Absolutely can't break anything.</li>
          <li>Almost as importantly, can't <i>change</i> anything.</li>
          <li>Needs to be as simple as possible without compromising performance.</li>
          <li>Lots of great tools and modules that app developers can use aren't available
          to developers writing instrumentation.</li>
        </ul>
      </section>

      <section>
        <h2>Prerequisites for Working with Node core</h2>

        <ul>
          <li>Learn how V8 works: <a href="http://mrale.ph/">mrale.ph</a>
          and <a href="http://wingolog.org">wingolog.org</a> are your guides.</li>
          <li>Learn to use <code>node debug</code> or <code>node-inspector</code>.
          <li>Spend some time with <code>src/node.js</code>, <code>src/node.cc</code>,
          and <code>lib/*</code>.
          <li><i>Don't</i> use Node's source as a model. Tuned for performance, not for
          simplicity.</li>
        </ul>
      </section>
    </section>

    <section>
      <h1>Solutions, workarounds, gross hacks</h1>
    </section>

    <section>
      <h2>Tools</h2>

      <ul>
        <li><code>'use strict';</code></li>
        <li>jshint</li>
        <li><code>node debug</code></li>
        <li>Testing and benchmarking framework included with Node's source.</li>
      </ul>
    </section>

    <section>
      <h2>Use Node's core abstractions</h2>

      <ul>
        <li>EventEmitters</li>
        <li>streams -- <code>in.pipe(out)</code> if nothing else</li>
        <li>domains</li>
      </ul>
    </section>

    <section>
      <h2>use ES5</h2>

      <ul>
        <li><code>forEach</code>, <code>map</code>, and <code>reduce</code>
        are built into Array.</li>
        <li><code>Object.keys()</code> is a simple way to enumerate object properties.</li>
        <li><code>Function.bind()</code> is a cleaner way of capturing <code>this</code></li>
      </ul>
    </section>

    <section>
      <section>
        <h1>Monkeypatching</h1>

        <pre><code class="javascript" data-trim>
var http = require('http');
var _request = http.request;
http.request = function () {
  console.log("requestin'");
  return _request.apply(this, arguments);
};
        </code></pre>
      </section>

      <section>
        <h2>Monkeypatch safely</h2>

        <p>Fail via early return rather than throwing:</p>
        <pre><code class="javascript" data-trim>
function wrap(nodule, name, wrapper) {
  if (!nodule || !nodule[name] || !wrapper) return;
  // other stuff
}
        </code></pre>
      </section>

      <section>
        <h2>Monkeypatch safely</h2>

        <p>Log everything:</p>
        <pre><code class="javascript" data-trim>
var logger = require('logger');
function wrap(nodule, name, wrapper) {
  logger.debug("Attempting to wrap %s.%s", nodule, name);
  if (!nodule || !nodule[name]) {
    logger.warn("no function to wrap provided");
    return;
  }
  if (!wrapper) {
    logger.warn("no wrapper function provided");
    return;
  }
  // other stuff
}
        </code></pre>
      </section>

      <section>
        <h2>Monkeypatch safely</h2>

        <p>Leave visible traces:</p>
        <pre><code class="javascript" data-trim>
function wrap(nodule, name, wrapper) {
  // setup
  var wrapped = wrapper(nodule[name]);
  wrapped.__WRAPPED = "yo dawg";

  nodule[name] = wrapped;
}
        </code></pre>
      </section>

      <section>
        <h2>Monkeypatch safely</h2>

        <p>Wrap and unwrap idempotently:</p>
        <pre><code class="javascript" data-trim>
function wrap(nodule, name, wrapper) {
  // other setup
  if (nodule[name].__WRAPPED) return;
  var original = nodule[name];

  var wrapped = wrapper(original);
  wrapped.__WRAPPED = "yo dawg";
  wrapped.__UNWRAP = function () {
    nodule[name] = original;
  };

  nodule[name] = wrapped;
}

function unwrap(method) {
  if (method.__UNWRAP) method.__UNWRAP();
}
        </code></pre>
      </section>

      <section>
        <h2>Monkeypatch safely</h2>

        <p>Always return the results of wrapped calls:</p>
        <pre><code class="javascript" data-trim>
function wrapper(original) {
  return function () {
    console.log("yo dawg: before");

    var returned = original.apply(this, arguments); // XXX

    console.log("yo dawg: the dawggening");

    return returned;
  };
}
        </code></pre>
      </section>
    </section>

    <section>
      <section>
        <h2>Keep it simple: Don't try to metaprogram in JavaScript</h2>

        <ul>
          <li>Magic is bad.</li>
          <li>Magic is super fun.</li>
          <li>Metaprogramming is magic.</li>
          <li class="fragment"><strike>Therefore, metaprogramming is super
          fun.</strike></li>
          <li class="fragment">Therefore, metaprogramming is bad.</li>
        </ul>
      </section>

      <section>
        <h2>How not to metaprogram in JavaScript</h2>

        <ul>
          <li>Don't control flow via function arity.</li>
          <li><code>Object.defineProperty()</code> and friends can be
          confusing and slow.</li>
          <li>Leave req and res alone: prefer composition to extension.</li>
        </ul>

        <aside class="notes">
          * JavaScript doesn't have method overriding or multimethod dispatch,
            and simulating that by dispatching on the number of parameters is
            surprising and difficult to monkeypatch correctly.
          * modifying the behavior of built-in objects increases the risk of
            breaking on new releases or when using others' modules.
        </aside>
      </section>
    </section>

    <section>
      <h2>Keep it simple: Use ONE strategy for control flow</h2>

      <p>raw events / streams, <code>async</code>, a promises library, TameJS,
      <code>streamline</code>, fibers, monads, <code>reducers</code>, Iced
      CoffeeScript, something you wrote yourself...</p>
      <p><i>...just pick one per project and stick with it.</i></p>
      <p class="fragment">also, can we please stop arguing about this now?</p>
    </section>

    <section>
      <section>
        <h2>your friends, domains</h2>

        <p><small>A whole other topic: <a href="http://is.gd/domainion">http://is.gd/domainion</a>.</small></p>

        <ul>
          <li>allow you to layer error handling</li>
          <li><code>domain.bind()</code> and <code>domain.intercept()</code> allow
          you to pull all error handling into domains</li>
          <li>Domains can be used for problems aside from error-handling...</li>
          <li class="fragment">...but that's not what they're good at.</li>
        </ul>
      </section>

      <section>
        <h2>keep it simple: handle errors one way</h2>

        <ul>
          <li>when in doubt, use domains</li>
          <li>try clauses are computed gotos</li>
          <li>uncaughtException is unsafe</li>
        </ul>
      </section>
    </section>

    <section>
      <h2>I hate to be a jerk, but...</h2>

      <ul>
        <li>Develop using whatever the hell you want, but publish JavaScript</li>
        <li class="fragment">...better yet, just write JavaScript.</li>
      </ul>

      <aside class="notes">
        * for better or worse, it's the one language all Node developers share in common
        * makes it easier to accept contributions and collaborate
      </aside>
    </section>

    <section>
      <h3>In conclusion</h3>

      <p>Keep it simple, keep it safe.</p>
      <p>&nbsp;</p>
      <img width=476
           height=142
           src="http://25.media.tumblr.com/tumblr_m87bsc0tU61r9onvzo2_r1_500.gif"
           alt="Gandalf says keep it safe"/>
      <p>&nbsp;</p>
      <p><a href="http://is.gd/domainion">http://is.gd/domainion</a></p>
      <p><a href="http://twitter.com/othiym23">http://twitter.com/othiym23</a></p>
      <p><a href="http://npmjs.org/package/newrelic">http://npmjs.org/package/newrelic</a></p>
      <p><a href="http://newrelic.com/">http://newrelic.com/</a> <small>(we're <a href="https://newrelic.com/about/jobs">hiring</a>)</small></p>
      <p><a href="http://is.gd/nodepdx2013">http://is.gd/nodepdx2013</a></p>
    </section>
  </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.min.js"></script>

<script>

// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
  controls: true,
  progress: true,
  history: true,
  center: true,

  theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
  transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

  // Optional libraries used to extend on reveal.js
  dependencies: [
    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
    { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
    // { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
    // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
  ]
});

</script>

</body>
</html>
